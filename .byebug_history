continue
      return @app.call(env) if IP_WHITELIST.include? env['REMOTE_ADDR']
exit
exi
      return if ENV['IP_FILTERING_ENABLE'] == nil || ENV['IP_FILTERING_ENABLE'] == false
ENV['IP_FILTERING_ENABLE']
IP_WHITELIST
ENV['IP_FILTERING_ENABLE']
continue
ENV['IP_FILTERING_ENABLE']
exit
ENV['IP_FILTERING_ENABLE']
ActiveModel::Type::Boolean.new.cast(ENV['IP_FILTERING_ENABLE'])
      return unless ActiveModel::Type::Boolean.new.cast(ENV['IP_FILTERING_ENABLE'])
continue
      return @app.call(env) if IP_WHITELIST.include? env['REMOTE_ADDR']
      return unless ActiveModel::Type::Boolean.new.cast(ENV['IP_FILTERING_ENABLE'])
continue
      return @app.call(env) if IP_WHITELIST.include? env['REMOTE_ADDR']
      return unless ActiveModel::Type::Boolean.new.cast(ENV['IP_FILTERING_ENABLE'])
continue
context.as_json
context.query
context.dataloader
context.to_s
context.methods
context.request
context
request
response
request.headers
(request.headers
continue
response.body
exit
response.body
continue
exit
response.body
response
continue
response.body
continue
get "/test"
continue
get "/test"
exit
get "/test"
            get '/test', params: {}
continue
            post '/graphql', params: {}
            get '/graphql', params: {}
            get '/index', params: {}
            get '/', {}
            get '/', params: {}
            get '/', params: {}, as: :json
continue
post.reload
continue
user.id
post
post.reload
post.realod
continue
contunue
exit
contunue
args
        Contexts::Posts::Repository.new.add_like(args: args, current_user_id: context[:current_user].id)
continue
exit
post[:likes]
user.id
post
post.reload
result
          expect { HealthSchema.execute(query, variables: not_valid_variables, context: { current_user: user }) }.to raise_error(ActiveRecord::RecordNotFound)
exit
      expect(event_store).to have_published(an_event(PostWasCreated))
continue
      Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
    $event_store.subscribe(Contexts::Users::Commands::CreateSingleUser.new, to: [UserWasCreated])
end
  end
    end
      end
        end
          { user: user, token: token }
          context[:session][:token] = token
          token = crypt.encrypt_and_sign("user-id:#{user.id}")
          crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
          # use Ruby on Rails - ActiveSupport::MessageEncryptor, to build a token
          return unless user.authenticate(credentials[:password])
          return unless user
          # ensures we have the correct user
          user = User.find_by email: credentials[:email]
          return unless credentials
          # basic validation
        def call(credentials:, context:)
      class SignInUser
    module Queries
  module Users
module Contexts
end
  end
    resource '*', headers: :any, methods: [:get, :post, :patch, :put]
    origins '*'
  allow do
Rails.application.config.middleware.insert_before 0, Rack::Cors do
continue
Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
continue
Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
continue
Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
continue
Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
continue
Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
exit
Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
continue
Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
continue
Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
continue
      Contexts::Users::Queries::SignInUser.new.call(credentials: credentials, context: context)
exit
Contexts::Users::Repository.new.create_user(auth_provider: auth_provider, name: name, phone_number: phone_number, gender: gender)
